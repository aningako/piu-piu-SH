#!/bin/bash
#================================================{ Functions }==========================================================
get_dimensions () {
    size=( $(stty size) )
    endx=${size[1]}
    endy=${size[0]}
enmyendy=$[endy-7]
boomendx=$[endx-10]
bullendx=$[endx-4 ]
heroendx=$[endx-15]
heroendy=$[endy-7 ]
enmyendy=$[endy-7 ]
bossendx=$[endx-11]
bossendy=$[endy-7 ]
bosshbar=$[endx-10]
lineendy=$[endy-2 ]
Sunsendx=$[endx-18]
tre1endy=$[endy-tree1H-2]
tre2endy=$[endy-tree2H-2]
tre3endy=$[endy-tree3H-2]
}

bye () { stty echo; printf "$CON$DEF"; exit $1; }
cut () { screen+="$1"; shift; printf -v spr %s "${@:$CS:$CL}"; screen+="${spr//_Z_/ }$SKY "; }
mov () {
    case $SC in
        0) [[ $OX -le -$OW ]] && return 1
           [[ $AS -ge  $AL ]] && AS=0 || ((AS++)) # sprites animation
           [[ $OX -le  1   ]] && ((CS++))
           ((OX--)); ((CL++)); SC=$SM;;
        *) ((SC--));;
    esac
    [[ $OX -le 1 ]] && SX=0 || SX=$OX
}

get_obj_data () {
    OT=${OI[0]}   # object type
    OX=${OI[1]}   # X coordinate
    OY=${OI[2]}   # Y coordinate
    OH=${OI[3]}   # object hight
    OW=${OI[4]}   # object width
    SC=${OI[5]}   # speed counter
    SM=${OI[6]}   # speed max
    CS=${OI[7]}   # cuting start
    CL=${OI[8]}   # cuting lenght
    AS=${OI[9]}   # animation start
    AL=${OI[10]}  # animation lenght
    [[ $OT ]] && sprite_$OT
}

server_read () {
    read -t$spd -srn1 input &> /dev/null
    case $input in
        [wW]) [[ $H1Y    -gt 1             ]] && ((H1Y--));;
        [aA]) [[ $H1X    -gt 1             ]] && ((H1X--));;
        [sS]) [[ $H1Y    -lt $heroendy     ]] && ((H1Y++));;
        [dD]) [[ $H1X    -lt $heroendx     ]] && ((H1X++));;
        [pP]) [[ $ammo -ge $G && $CD -eq 0 ]] && { CD=7; case $G in
            1) PIU+=("$H1CX $H1CY 1");;
            2) PIU+=("$H1CX $[$H1CY+1] 1" "$H1CX $[$H1CY-1] 1");;
            3) PIU+=("$H1CX $[$H1CY+1] 1" "$H1CX $[$H1CY-1] 1" "$[$H1CX+1] $H1CY 1");;
            4) PIU+=("$[$H1CX+1] $[$H1CY+1] 1" "$[$H1CX+1] $[$H1CY-1] 1" "$H1CX $[$H1CY+2] 1" "$H1CX $[$H1CY-2] 1");;
            5) PIU+=("$[$H1CX+1] $[$H1CY+1] 1" "$[$H1CX+1] $[$H1CY-1] 1" "$H1CX $[$H1CY+2] 1" "$H1CX $[$H1CY-2] 1" "$[$H1CX+2] $H1CY 1");;
        esac; ((ammo-=$G)); };;
    esac
}

boom () {
    XB=$1 YB=$2
    [[ $XB -gt $boomendx ]] && XB=$boomendx
    BP3+=("boom $XB $YB 0 0 0 2 0 0 0 5")
}

BOOM () {
    XB=$1 YB=$2
    [[ $XB -gt $boomendx ]] && XB=$boomendx
    BP3+=("boom  $XB     $YB    0 0 0 $[RANDOM%3] 0 0 0 5"
          "boom $[XB+5]  $YB    0 0 0 $[RANDOM%3] 0 0 0 5"
          "boom $[XB+1] $[YB+2] 0 0 0 $[RANDOM%3] 0 0 0 5"
          "boom $[XB+5] $[YB+2] 0 0 0 $[RANDOM%3] 0 0 0 5"
          "boom  $XB    $[YB+1] 0 0 0 $[RANDOM%3] 0 0 0 5")
}

fps_counter () {
    [[ $SECONDS -gt $sec ]] && {
        FPS=$FPSC AVG+=($FPS)
        [[ $FPSL ]] || FPSL=$FPS
        [[ $FPS -gt $FPSM  ]] && FPSM=$FPS
        [[ $FPS -lt $FPSL  ]] && FPSL=$FPS
        (( ${#AVG[@]} == 5 )) && { avg="${AVG[@]}"; FPSA=$(( (${avg// /+})/5 )); AVG=(); }
        sec=$SECONDS
        FPSC=0
    } || ((FPSC++))
}

fill_screen () {
    for ((i=0;         i<$lineendy; i++)); do printf "$SKY%${endx}s"; done
    for ((i=$lineendy; i<$endy;     i++)); do printf "$LND%${endx}s"; done
}

add_backgound () {
    #-{ Add msngr }------------------------------------------------------------
    case $[RANDOM % $MSN] in 0) BP2+=("msngr $endx $[RANDOM%enmyendy+3] 4 20 0 $[RANDOM%2] 1 0 $[RANDOM%3] 3");; esac

    #-{ Add clouds }-----------------------------------------------------------
    case $[RANDOM % $CLD]:$[RANDOM % 3 + 1] in
        0:1) BP1+=("cloud1 $endx $[RANDOM % 10 + 2] 3 6  6 6 1 0 0 0");;
        0:2) BP2+=("cloud2 $endx $[RANDOM % 10 + 2] 3 8  4 4 1 0 0 0");;
        0:3) BP3+=("cloud3 $endx $[RANDOM % 10 + 2] 3 11 2 2 1 0 0 0");;
    esac

    #-{ Add trees }------------------------------------------------------------
    case $[RANDOM % $TRE]:$[RANDOM % 3 + 1] in
        0:1) BP1+=("tree1 $endx $tre1endy 3 2 6 6 1 0 0 0");;
        0:2) BP2+=("tree2 $endx $tre2endy 6 5 4 4 1 0 0 0");;
        0:3) BP3+=("tree3 $endx $tre3endy 9 9 2 2 1 0 0 0");;
    esac

    #-{ Print moving land }----------------------------------------------------
    screen+="\e[$lineendy;1H$LND${land:$[1-$LX]:$endx}"; [[ $LX -lt -$[$LN/2] ]] && LX=-1 || ((LX--))
}
